### 派发更新
在 `defineReactive.md` 中已经讲了 在 对 data 属性 设置 ` get` 函数 中 里面 进行 依赖 收集， 对于 派发更新 是如何 操作 的，
来看下 `setter` 里的 逻辑
```
set: function reactiveSetter (newVal) {
    const value = getter ? getter.call(obj) : val
    /* eslint-disable no-self-compare */
    if (newVal === value || (newVal !== newVal && value !== value)) {
    return
    }
    /* eslint-enable no-self-compare */
    if (process.env.NODE_ENV !== 'production' && customSetter) {
    customSetter()
    }
    // #7981: for accessor properties without setter
    if (getter && !setter) return
    if (setter) {
    setter.call(obj, newVal)
    } else {
    val = newVal
    }
    childOb = !shallow && observe(newVal)
    dep.notify()
}
```
核心代码 就是 这段
```
childOb = !shallow && observe(newVal)
dep.notify()
```
对 赋值 对象 也进行 了 observe （响应式处理），然后 `dep.notify()`
我们之前 在 分析 dep 管理 器中 ，dep 有个 subs 属性 里面 存储这 watcher 实例，
而 dep.notify() 就是 遍历 这些 watcher 实例 执行 它的 update 方法
```
for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
```
所以我们看下 watcher 的 `update` 方法

```
update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }

```
对于 `lazy , sync`，是对 computed 和 watch 选项单独处理，来看下 `queueWatcher(this)` 

```
function queueWatcher (watcher: Watcher) {
  const id = watcher.id
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    // queue the flush
    if (!waiting) {
      waiting = true

      if (process.env.NODE_ENV !== 'production' && !config.async) {
        flushSchedulerQueue()
        return
      }
      nextTick(flushSchedulerQueue)
    }
  }
}

```
`queueWatcher` 中 将 watcher 实例 推入 一个 数组 中 ，期间 用 一个 对象 (has) 来避免 重复 推入 一个 watcher 实例， 例如 推入 多个 watcher 实例

之后执行 `nextTick(flushSchedulerQueue)`, netTick 在 `nextTick.md` 已经解析了 ，主要 是开启一个 异步任务 然后 执行 ， 所以 我只需要 知道 nextTick 的 回调 在 异步任务结束后执行，所以 我们改变 data 对象 也不是 立马 更新视图
看下 `flushSchedulerQueue`

```
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow()
  flushing = true
  let watcher, id

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort((a, b) => a.id - b.id)

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index]
    if (watcher.before) {
      watcher.before()
    }
    id = watcher.id
    has[id] = null
    watcher.run()
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? `in watcher with expression "${watcher.expression}"`
              : `in a component render function.`
          ),
          watcher.vm
        )
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  resetSchedulerState()

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue)
  callUpdatedHooks(updatedQueue)

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush')
  }
}

```
首先 把 queue 队列 的 watcher 实例 排序下 ，我们知道 组件 的 创建 过程 是 先父后 子 的 ，所以 更新 也是 先父 后子
再 对 queue 遍历 执行 before 等等，更新 的 核心 是 `watcher.run()`, resetSchedulerState() 是 重置 标志位 状态，
callActivatedHooks(activatedQueue), callUpdatedHooks(updatedQueue) 这些 是 执行 一些 update 的 钩子函数 ，后面分析
看下 `watcher.run()`

```
run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
}

```
在 之前 就讲到 vue 在 挂载 的时候 就有个 默认 的 首次 渲染 ，也就是 执行 了 watcher 的get 函数，

这里 更新 也是 执行 了 get 函数，所以 针对 渲染 watcher , 就是 执行 get 函数 触发 
```
updateComponent = () => {
  vm._update(vm._render(), hydrating)
}
```
所以 就执行 了 `render -> patch` 操作

之后 `value` 和 `this.value` 的 比对则是 对 watch 选项 的 也就是 对应 `newValue` 和 `oldValue` 
关于 对 `computed` 和 `watch` 的分析 见 `computed&watch.md`,这两个 都是 用 watcher 实例化的